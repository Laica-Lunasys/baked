ブロックの仕組み

1. ブロックディレクトリ
2. 設定ファイル
3. モデル
4. コントローラ
5. ビュー
6. リソース

1. ブロックの仕組み

ブロックはCakePHPのプラグイン機能によって実現しています。ブロックフォルダそのものがCakePHPのプラグインになっています。ブロックフォルダの設置先は「app/Plugin」ディレクトリで、ディレクトリ名は「Block」の接頭辞が必要です。

下記はブロックフォルダのツリー構造です。

BlockName ブロックフォルダ
  Config 設定フォルダ
    bootstrap.php 設定ファイル
  Controller コントローラフォルダ
    ThemeNameApiController.php APIコントローラ
  Model モデルフォルダ
    ThemeName.php モデルファイル
  View ビューフォルダ
    Elements 部品ビューのフォルダ
      block.ctp 表示用ビュー
      editor.ctp 編集用ビュー
  webroot ブロックルートフォルダ
    css CSSフォルダ
      block.css 表示中に読み込まれるcssファイル
      editor.css 編集中に表示するcssファイル
    js JSフォルダ
      block.js 表示中に読み込まれるjsファイル
      editor.js 編集中に読み込まれるjsファイル

2. 設定ファイル

ブロックフォルダには必ず設定ファイルを作成してください。パスは「BlockName/Config/bootstrap.php」です。

設定ファイルでは、そのブロックプラグインの情報を設定します。

<?php
Configure::write('Blocks.BlockName(ブロックプラグインの名前)', array(
  'name' => __('適当なブロックの名前'),
  'icon' => 'icon-picture', // アイコン名
));

BlockNameはブロックフォルダの名前と一致させてください。iconキーに設定する値は、下記URLから選ぶことができます。
http://fortawesome.github.io/Font-Awesome/icons/

Bakedは、下記のファイルを適当なタイミングで探して読み込みます。

|パス|タイミング|用途|
|BlockName/webroot/css/block.css|サイト表示中|表示用ビュー(BlockName/View/Elements/block.ctp)に適用する|
|BlockName/webroot/css/editor.css|サイト編集中|編集用ビュー(BlockName/View/Elements/editor.ctp)に適用する|
|BlockName/webroot/js/block.js|サイト表示中|ブロックの動作に必要なコードを書く|
|BlockName/webroot/js/editor.js|サイト編集中|ブロックの編集に必要なコードを書く|

これらのファイルはもし存在すれば自動的に読み込まれますが、
別途読み込ませたいファイルがあるときは、設定ファイルに下記のように設定することもできます。

// 表示中
Baked::add('CSS', array(
  'BlockName.show/show_1.css',
  'BlockName.show/show_2.css',
));

// 編集中
Baked::add('CSS_EDITTING', array(
  'BlockName.editor/editor_1.css',
  'BlockName.editor/editor_2.css',
));

この設定により、サイト表示中は「BlockName/webroot/css/show/show_1.css」「BlockName/webroot/css/show/show_2.css」が読み込まれ、さらにサイトの編集中は「BlockName/webroot/css/editor_editor_1.css」「BlockName/webroot/css/editor/editor_2.css」読み込まれます。

また、同じような方法で、JSを読み込むことも可能です。

// 表示中
Baked::add('JS', array(
  'BlockName.show/show.js',
));

// 編集中
Baked::add('JS', array(
  'BlockName.editor/editor.js',
));

これでサイト表示中は「BlockName/webroot/js/show/show.js」が、さらに編集中は「BlockName/webroot/js/editor/editor.js」が読み込まれます。


3. モデル

モデルは必ず必要なファイルで、付けるべき名前も決まっています。
BlockName/Model/以下に、{プラグイン名}.phpというファイル名で、プラグイン名と同じく名前のクラスを作成してください。
例えば、プラグイン名をBlockRssFeedという名前にする場合、下記のようになります。

// app/Plugin/BlockRssFeed/Model/BlockRssFeed.php

<?php
App::uses('BlockAppModel', 'Model');

class BlockRssFeed extends BlockAppModel
{
  public $name = 'BlockRssFeed';
}

モデルに最低限必要なコードは上記だけです。
2行目でBlockAppModelクラスを読み込んでいます。作成するモデルは必ずBlockAppModelのサブクラスでなければなりません。

ブロックが作成されると、Bakedはブロックが自由に読み書きできるデータの保存場所を用意します。この保存場所には一意のIDが付与されます。
ブロックが削除されると、Bakedはブロックと一緒にデータの保存場所を削除します。
モデルでやる仕事は、データの更新と削除です。

モデルに定義されるメソッド（具体的にはBlockAppModelで定義されているメソッド）には下記のようなものがあります。

public function updateData($id, $data)

１つ目のパラメータにはブロックのID(以後「ブロックID」)を、２つ目には保存したいデータを渡します。
データはBakedによってjson形式にエンコードされ保存されます。
成功した場合はtrue、失敗した場合はExceptionクラスのインスタンスが返ります。

下記のように使用します。

$this->updateData(1, array(
  'title' => 'Hello',
  'text' => 'World!'
));

次はデータの取得です。

public function getData($id)

パラメータにはブロックIDを指定します。保存したデータが返ってきます。
ブロックIDが存在しない場合はfalseが返ります。

データを保存する前にはバリデーションを実行しなければいけません。
バリデーションの実行はBakedが担当するので、モデルではバリデーションの設定だけを行います。
バリデーションの設定は、モデルクラスに$validという名前の変数を定義して行います。

class BlockName
{
  public $name = 'BlockName';
  public $valid = array(
    'add' => array(
      'title' => 'required | minLen[10] | maxLen[100]',
      'email' => 'required | email'
      'type' => 'inList(type1,type2)'
    ),
    'update' => array(
    ),
  );
}

addキーはブロックの新規追加時に使用され、updateキーはブロックの更新時に使用されます。addキーの配列は自動的にupdateキーに結合されます。

add/updateキーの中は配列で、その中のキーはupdateDataメソッドで渡すデータの配列のキーと対応しています。
値にはそれぞれバリデーションルールが設定され、'|'で区切られています。

Bakedはデータを作成/更新する際、このバリデーションルールを確認し、クリアした場合はデータ保存し、エラーがあった場合は適宜エラーを返します。
下記は設定できるバリデーションルールの一覧です。

|ルール|説明|使用例|
|required|必須入力。配列にキーがない場合はエラー||
|notEmpty|必須必須。配列にキーがない場合はクリア||
|alphaNumeric|半角英数字||
|between|半角文字。字数に範囲制限|between[1,10] 1文字以上かつ10文字以下||
|blank|値無し||
|cc|クレジットカード番号||
|date|日付形式||
|datetime|日付時間形式||
|decimal|小数点第n位までの半角数字|decimal[2] 小数点第2位まで|
|email|メールアドレス||
|equalTo|入力値の一致|equalTo[hello] 入力値が"hello"である|
|extension|拡張子の一致|extension(png,gif,jpg,jpeg) 拡張子がpng,gif,jpg,jpegのいずれか|
|ip|IPアドレス形式||
|minLen|最低文字数|minLen[5] 5文字以上|
|maxLen|最大文字数|minLen[10] 10文字以内|
|money|金額として正しい値||
|numeric|半角数字||
|phone|電話番号||
|postal|郵便番号||
|zip|郵便番号||
|range|n1より大きくn2より小さい半角数字|range(0,10) 0より大きく10より小さい|
|url|URL|
|inList|リストに存在する値|inList(1,2,3) 1,2,3のいずれか|
|time|時:分 形式|

$valid[update]には自動的に$valid[add]が結合されますが、その際に$valid[add]に含まれる'required'ルールは全て'notEmpty'に置換されます。

モデルにはBakedから自動的に呼ばれるコールバックメソッドがあります。
最もよく使うのは下記の２つです。

public function initialData()
{
  return array(
    'title' => 'Yahoo! トピックストップ',
    'url' => 'http://rss.dailynews.yahoo.co.jp/fc/rss.xml',
    'limit' => 5,
  );
}

上記のメソッドはブロックが新規作成された時に呼び出されます。返り値はブロックの初期データとなります。

次は、ブロックが削除される時に呼び出されるメソッドです。

public function willDelete($blockId)
{
  return TRUE;
}

引数にはブロックのIDが渡されます。
このメソッド内では独自に保存されたデータ（例えばフォトギャラリーのブロックでは画像など）を削除します。
このメソッドでfalseを返すと、ブロックの削除はキャンセルされます。
全てのデータをupdateDataメソッドで保存している場合は、willDeleteメソッドを定義する必要がありません。

4. コントローラ

コントローラの仕事は、ブロックの編集データを受取り、モデルを通して保存することです。
コントローラの雛形は下記の通りです。

<?php
/**
 * app/Plugin/BlockName/Controller/BlockNameApiController.php
 */

App::uses('BlockAppController', 'Controller');

class BlockNameApiController extends BlockAppController
{
  public $uses = array('BlockName.BlockName');
}

コントローラクラスはBlockAppControllerクラスのサブクラスである必要があります。コントローラのファイル名とクラス名は、必ずプラグイン名を接頭辞にしてください。１つ気をつけなければならないことは、「{プラグイン名}Controller」という名前は使えないことです。必ず「{プラグイン名}ApiController」や「{プラグイン名}UpdateController」など、適当な名前を付けてください。

クラスの中に、$usesというプロパティがあります。このプロパティには使用するモデル名を配列で渡します。上記では'BlockName.BlockName'となっています。「.」の前はプラグイン名で、後ろがモデル名です。モデル名はプラグイン名と同じにするべきなので、このような表記になっています。
$usesに渡したモデルは、コントローラのメソッドから下記のように使用することができます。

class BlockNameApiController extends BlockAppController
{
  public $uses = array('BlockName.BlockName');

  public function sample()
  {
    $this->BlockName->methodName(); // メソッドをコール
  }
}

コントローラには自由にメソッドを作成できます。それらのメソッドはブラウザからコールでき、今から作成するビューやjsファイルから手動でリクエストします。仮にコントローラ名を「BlockNameApiController」とし、下記のようなメソッドを作成した場合、http://yourbaked.com/plugin/block_name/block_name_api/メソッド名 というパスでアクセスすることができます。

public function hello()
{
  echo "Hello world!";
  exit;
}

上のメソッドを作りブラウザからアクセスすると、「Hello World!」と表示されるはずです。

しかし、データを更新するコントローラに、管理者ではないリクエストや、悪意ある攻撃(例えばXSRFなど)によるリクエストがくる可能性もあります。Bakedではそれらを防ぐメソッドを用意しています。「tokenFilter」と「staffFilter」です。
tokenFilterメソッドは、リクエストに正常なトークンが含まれているかを調べ、不正だと判断した場合はエラーを出力し終了します。トークンはサイトにアクセスしたユーザー全てのセッションに自動で保存されています。また、後述しますが、リクエストに適宜トークンを仕込む方法もBakedが提供します。
staffFilterメソッドは、リクエストユーザーが管理者であるかどうかを調べ、不正だと判断した場合はエラーを出力し終了します。
下記のように使います。

public function hello()
{
  $this->tokenFilter();
  $this->staffFilter();

  echo "Hello world!";
  exit;
}

エラー出力をjsonで行う場合は、「tokenFilterApi」「staffFilterApi」メソッドを使用してください。

public function hello()
{
  $this->tokenFilter();
  $this->staffFilter();

  $this->Api->ok(array(
    'text' => 'Hello world!'
  ));
}

Bakedではコントローラと通信するためのJavascriptクラスを用意しています。通常、そのJSクラスでは、コントローラからjson形式のレスポンスを期待しています。
また、コントローラからjsonを出力するクラス「ApiComponent」も用意されています。コントローラの$Apiプロパティにインスタンスが保存されています。

下記のように使います。

public function hello()
{
  $this->Api->ng('エラーメッセージ');
}













